---
title: 数据库——mysql的四种事务隔离级别
date:  2016-11-10
categories:  数据库
keywords:  [数据库，mysql，事务隔离级别]
tags: 
	- 数据库
	- mysql
	- 事务隔离级别
---

> 在Java中，对于变量我们有AtomicXXX来保证原子性，对于程序片段我们有sychronized或者lock锁来保证原子性。而在数据库中，我们用数据库事务来保证操作的原子性，那么事务跟事务之间，也需要一种机制来防止数据的脏读、多读或者幻读。接下来我们将讨论SQ标准定义的四种事务隔离级别。

# 概要
- SQL标准定义了4类隔离级别，包括了一些具体的规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。而越高级的隔离级别可见性越低，数据一致性越有保证，相反，并发处理能力越低，系统开销越大。这也是安全和性能的一个永恒的话题。
- 下面这张表显示的就是四种隔离级别以及可能产生的问题，越往下隔离级别越高。

| 隔离级别| 脏读 |不可重复读|幻读|
| ------------- |:-------------:|:---:|:---:|
|**RU（Read Uncommitted读未提交）**|yes|yes|yes|
|**RC（Read Committed读提交）**|no|yes|yes|
|**RR（Repeated Read可重复读）**|no|no|yes|
|**Serializable可串行化**|no|no|no|
	
> 首先我们先解释一下三种数据一致性问题:脏读、不可重复读一级幻读。

- 脏读(Dirty Read)

	简单的说就是，一个事物读取了另一个数据被回滚的数据。那么这个数据就是脏数据。简称读了旧数据。

- 不可重复读(Non-repeatable read)

	简单的说就是在一个事务里，数据被另一个事务改变了，造成重复读的数据不一样。这就是不可重复读。简称读了新旧数据。

- 幻读(Phantom Read)

	和不可重复读相比，这一次数据的值其实没变，而是前后两次后者多了数据。因为在一个事务里另一个数据添加了几条数据。

# RU隔离级别

在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也就是脏读。

# RC隔离级别

这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。
该隔离级别，通过让事务与事务之间不可见，从而只能读到其他事务提交之后的数据达到的。

# RC隔离级别

这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。

该隔离级别，是通过将事务涉及到的所有行锁住，等到该事物提交再释放的原则，防止了不可重复读问题。注意它只是所的涉及到的行，没有设计的行别没有锁，所以它仍然会造成幻读的情况。但是在一些其他的数据库中，采用了MVCC的机制，从而避免了幻读的情况，在这里就不再赘述了。

**注意：**大多数的MySQL事务型存储引擎，如InnoDB，Falcon以及PBXT都不使用一种简单的行锁机制。事实上，他们都和另外一种用来增加并发性的被称为“多版本并发控制（MVCC）”的机制来一起使用。

# Serializable隔离级别

这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。
该级别，就像java中的锁一样，保证了线程执行的顺序问题，从而保证了原子性一样。而mysql中的表相当于锁对象，一个个事务就相当于一个个线程去争取锁一样。其中mysql具体使用的是行锁 + 间隙锁gap解决幻读问题。

# 数据库锁
MySQL InnoDB支持三种行锁定方式：

1. 行锁（Record Lock）:锁直接加在索引记录上面，锁住的是key。
2. 间隙锁（Gap Lock）:锁定索引记录间隙，确保索引记录的间隙不变。间隙锁是针对事务隔离级别为可重复读或以上级别而已的。
3. Next-Key Lock ：行锁和间隙锁组合起来就叫Next-Key Lock。

	默认情况下，InnoDB工作在可重复读隔离级别下，并且会以Next-Key Lock的方式对数据行进行加锁，这样可以有效防止幻读的发生。Next-Key Lock是行锁和间隙锁的组合，当InnoDB扫描索引记录的时候，会首先对索引记录加上行锁（Record Lock），再对索引记录两边的间隙加上间隙锁（Gap Lock）。加上间隙锁之后，其他事务就不能在这个间隙修改或者插入记录。
 
	Gap Lock在InnoDB的唯一作用就是防止其他事务的插入操作，以此防止幻读的发生。

-------------------------------------------
>**注意**：转载请标明，转自[itboy-木小草](http://muxiaocao.cn)。
>**尊重原创，尊重技术。**